// -*- coding: utf-8 -*-
// Copyright (C) 2020 Laboratoire de Recherche et Développement
// de l'Epita (LRDE).
//
// This file is part of Spot, a model checking library.
//
// Spot is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// Spot is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
// License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#pragma once

#include <iosfwd>
#include <spot/misc/bddlt.hh>
#include <spot/misc/common.hh>
#include <spot/misc/minato.hh>
#include <spot/twa/fwd.hh>
#include <unordered_map>
#include <vector>
#include <set>
#include <memory>
#include <sstream>

namespace spot
{
  // TODO: Déplacer cette doc.
  /// \ingroup twa_io
  /// \brief Encode and print an automaton as an AIGER circuit.
  ///
  /// The circuit actually encodes the transition relation of the automaton, not
  /// its acceptance condition. Therefore, this function will reject automata
  /// whose acceptance condition is not trivial (i.e. true).
  /// States are encoded by latches (or registers) in the circuit. Atomic
  /// propositions are encoded as inputs and outputs of the circuit. To know
  /// which AP should be encoded as outputs, print_aiger() relies on the named
  /// property "synthesis-outputs", which is a bdd containing the conjunction of
  /// such output propositions. All other AP are encoded as inputs. If the named
  /// property is not set, all AP are encoded as inputs, and the circuit has no
  /// output.
  ///
  /// \pre  In order to ensure correctness, edge conditions have
  /// to have the form (input cond) & (output cond). The output cond
  /// does not need to be a minterm.
  /// Correct graphs are generated by spot::unsplit_2step
  ///
  ///
  /// \param os           The output stream to print on.
  /// \param aut          The automaton to output.
  /// \param mode         Determines how the automaton is encoded.
  ///                     "ISOP" Uses DNF.
  ///                     "ITE" Uses the "if-then-else" normal-form
  // SPOT_API std::ostream&
  // print_aiger(std::ostream& os, const const_twa_ptr& aut,
  //             const char* mode);

  namespace
  {
    static std::vector<std::string>
    name_vector(unsigned n, const std::string &prefix)
    {
      std::vector<std::string> res(n);
      for (unsigned i = 0; i != n; ++i)
        res[i] = prefix + std::to_string(i);
      return res;
    }
  }

  class aig;

  using aig_ptr = std::shared_ptr<aig>;
  using const_aig_ptr = std::shared_ptr<const aig>;


  // A class to represent an AIGER circuit
  // TODO: On garde ce nom ou "aiger" ?
  class aig
  {
  public:
    unsigned max_var_;
    unsigned num_inputs_;
    unsigned num_latches_;
    unsigned num_outputs_;

    std::vector<unsigned> latches_;
    std::vector<unsigned> outputs_;
    std::vector<std::string> input_names_;
    std::vector<std::string> output_names_;
    std::vector<std::pair<unsigned, unsigned>> and_gates_;
    // Cache the function computed by each variable as a bdd.
    std::unordered_map<unsigned, bdd> var2bdd_;
    std::unordered_map<bdd, unsigned, bdd_hash> bdd2var_;

    aig(const std::string& aig_txt)
    {
      std::istringstream iss(aig_txt);
      std::string line;
      std::ostringstream error_oss;
      error_oss << "aig(std::string): line ";
      getline(iss, line);
      unsigned line_number = 1;
      unsigned max_index, nb_inputs, nb_latches, nb_outputs, nb_and;
      if (sscanf(line.c_str(), "aag %u %u %u %u %u", &max_index, &nb_inputs, &nb_latches, &nb_outputs, &nb_and) != 5)
      {
        error_oss << line_number << " invalid header";
        throw std::runtime_error(error_oss.str());
      }
      num_inputs_ = nb_inputs;
      num_latches_ = nb_latches;
      num_outputs_ = nb_outputs;
      input_names_.reserve(num_inputs_);
      output_names_.reserve(num_outputs_);
      latches_.reserve(num_latches_);
      outputs_.reserve(num_outputs_);
      // FIXME:
      max_var_ = -2U;
      for (unsigned i = 0; i < nb_inputs; ++i)
      {
        if (!iss)
        {
          error_oss << line_number << " missing input";
          throw std::runtime_error(error_oss.str());
        }
        line.clear();
        getline(iss, line);
        ++line_number;
      }
      for (unsigned i = 0; i < nb_latches; ++i)
      {
        if (!iss)
        {
          error_oss << line_number << " missing latch";
          throw std::runtime_error(error_oss.str());
        }
        line.clear();
        getline(iss, line);
        ++line_number;
        unsigned current_state, next_state;
        if (sscanf(line.c_str(), "%u %u", &current_state, &next_state) != 2)
        {
          error_oss << line_number << " invalid latch";
          throw std::runtime_error(error_oss.str());
        }
      }
      for (unsigned i = 0; i < nb_outputs; ++i)
      {
        if (!iss)
        {
          error_oss << line_number << " missing output";
          throw std::runtime_error(error_oss.str());
        }
        line.clear();
        getline(iss, line);
        ++line_number;
        unsigned num_out;
        if (sscanf(line.c_str(), "%u", &num_out) != 1)
        {
          error_oss << line_number << " invalid output";
          throw std::runtime_error(error_oss.str());
        }
        set_output(i, num_out);
      }
      for (unsigned i = 0; i < nb_and; ++i)
      {
        unsigned lhs, rhs, and_gate;
        if (!iss)
        {
          error_oss << line_number << " missing AND";
          throw std::runtime_error(error_oss.str());
        }
        line.clear();
        getline(iss, line);
        ++line_number;
        if (sscanf(line.c_str(), "%u %u %u", &lhs, &rhs, &and_gate) != 3)
        {
          error_oss << line_number << " invalid AND";
          throw std::runtime_error(error_oss.str());
        }

        if (and_gate != aig_and(lhs, rhs))
        {
          // TODO: Est-ce vrai ?
          throw std::runtime_error("aig(std::string): invalid input");
        }
      }
      line.clear();
      getline(iss, line);
      ++line_number;
      while (iss)
      {
        unsigned pos_var_name;
        char first_char = line[0];
        char var_name[256];
        switch (first_char)
        {
          // latches names non supported
        case 'l':
        {
          line.clear();
          getline(iss, line);
          ++line_number;
          continue;
        }
        case 'i':
        {
          if ((sscanf(line.c_str(), "i%u %255s", &pos_var_name, var_name) != 2) || pos_var_name >= num_inputs_)
          {
            error_oss << line_number << " invalid input name";
            throw std::runtime_error(error_oss.str());
          }

          input_names_[pos_var_name] = var_name;
          line.clear();
          getline(iss, line);
          ++line_number;
          break;
        }
        case 'o':
        {
          if (sscanf(line.c_str(), "o%u %255s", &pos_var_name, var_name) != 2 || pos_var_name >= num_outputs_)
          {
            error_oss << line_number << " invalid output name";
            throw std::runtime_error(error_oss.str());
          }
          output_names_[pos_var_name] = var_name;
          line.clear();
          getline(iss, line);
          ++line_number;
          break;
        }
        case 'c':
          return;
        default:
        {
          error_oss << line_number << " invalid line";
          throw std::runtime_error(error_oss.str());
        }
        }
      }
    }

    aig(const std::vector<std::string> &inputs,
        const std::vector<std::string> &outputs,
        unsigned num_latches)
        : max_var_((inputs.size() + num_latches) * 2),
          num_inputs_(inputs.size()),
          num_latches_(num_latches),
          num_outputs_(outputs.size()),
          latches_(num_latches),
          outputs_(outputs.size()),
          input_names_(inputs),
          output_names_(outputs)
    {
      bdd2var_[bddtrue] = 1;
      var2bdd_[1] = bddtrue;
      bdd2var_[bddfalse] = 0;
      var2bdd_[0] = bddfalse;

      bdd2var_.reserve(4 * (num_inputs_ + num_latches_));
      var2bdd_.reserve(4 * (num_inputs_ + num_latches_));
    }

    aig(unsigned num_inputs, unsigned num_latches, unsigned num_outputs)
        : aig(name_vector(num_inputs, "in"), name_vector(num_outputs, "out"),
              num_latches)
    {
    }

    // register the bdd corresponding the an
    // aig literal
    SPOT_API void register_new_lit(unsigned v, const bdd &b);

    SPOT_API unsigned input_var(unsigned i) const;

    SPOT_API unsigned latch_var(unsigned i);

    SPOT_API unsigned gate_var(unsigned i) const;

    SPOT_API void set_output(unsigned i, unsigned v);

    SPOT_API void set_latch(unsigned i, unsigned v);

    SPOT_API unsigned aig_true() const;

    SPOT_API unsigned aig_false() const;

    SPOT_API unsigned aig_not(unsigned v);

    SPOT_API unsigned aig_and(unsigned v1, unsigned v2);

    SPOT_API unsigned aig_and(std::vector<unsigned> vs);

    SPOT_API unsigned aig_or(unsigned v1, unsigned v2);

    SPOT_API unsigned aig_or(std::vector<unsigned> vs);

    SPOT_API unsigned aig_pos(unsigned v);

    SPOT_API void remove_unused();

    // Takes a bdd, computes the corresponding literal
    // using its DNF
    SPOT_API unsigned bdd2DNFvar(const bdd &b,
                                const std::unordered_map<unsigned, unsigned> &
                                    bddvar_to_num);

    // Takes a bdd, computes the corresponding literal
    // using its INF
    SPOT_API unsigned bdd2INFvar(bdd b);
  };

  typedef std::shared_ptr<aig> aig_ptr;

  SPOT_API std::ostream &

  print_aiger(std::ostream &os, const_aig_ptr circuit, const char *opt);

  SPOT_API aig_ptr
  strategy_to_aig(const const_twa_ptr &aut, const char *mode);

  SPOT_API aig_ptr
  strategy_to_aig(const twa_ptr &aut, const char *mode,
                  const std::set<std::string>& ins,
                  const std::set<std::string>& outs);
}
