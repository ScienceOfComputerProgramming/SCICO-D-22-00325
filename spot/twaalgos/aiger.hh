// -*- coding: utf-8 -*-
// Copyright (C) 2020 Laboratoire de Recherche et Développement
// de l'Epita (LRDE).
//
// This file is part of Spot, a model checking library.
//
// Spot is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// Spot is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
// License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#pragma once

#include <iosfwd>
#include <spot/misc/bddlt.hh>
#include <spot/misc/common.hh>
#include <spot/misc/minato.hh>
#include <spot/twa/fwd.hh>
#include <unordered_map>
#include <vector>
#include <set>
#include <memory>
#include <sstream>

namespace spot
{
  // TODO: Déplacer cette doc.
  /// \ingroup twa_io
  /// \brief Encode and print an automaton as an AIGER circuit.
  ///
  /// The circuit actually encodes the transition relation of the automaton, not
  /// its acceptance condition. Therefore, this function will reject automata
  /// whose acceptance condition is not trivial (i.e. true).
  /// States are encoded by latches (or registers) in the circuit. Atomic
  /// propositions are encoded as inputs and outputs of the circuit. To know
  /// which AP should be encoded as outputs, print_aiger() relies on the named
  /// property "synthesis-outputs", which is a bdd containing the conjunction of
  /// such output propositions. All other AP are encoded as inputs. If the named
  /// property is not set, all AP are encoded as inputs, and the circuit has no
  /// output.
  ///
  /// \pre  In order to ensure correctness, edge conditions have
  /// to have the form (input cond) & (output cond). The output cond
  /// does not need to be a minterm.
  /// Correct graphs are generated by spot::unsplit_2step
  ///
  ///
  /// \param os           The output stream to print on.
  /// \param aut          The automaton to output.
  /// \param mode         Determines how the automaton is encoded.
  ///                     "ISOP" Uses DNF.
  ///                     "ITE" Uses the "if-then-else" normal-form
  // SPOT_API std::ostream&
  // print_aiger(std::ostream& os, const const_twa_ptr& aut,
  //             const char* mode);

  namespace
  {
    static std::set<std::string>
    name_vector(unsigned n, const std::string &prefix)
    {
      std::set<std::string> res;
      for (unsigned i = 0; i != n; ++i)
        res.emplace(prefix + std::to_string(i));
      return res;
    }
  }

  class aig;

  using aig_ptr = std::shared_ptr<aig>;
  using const_aig_ptr = std::shared_ptr<const aig>;


  // A class to represent an AIGER circuit
  // TODO: On garde ce nom ou "aiger" ?
  // Non on garde car aiger c'est le format du fichier
  // aig c'est and-inverter-graph
  class SPOT_API aig
  {
  public:
    const unsigned num_inputs;
    const unsigned num_outputs;
    const unsigned num_latches;
    const std::set<std::string> input_names;
    const std::set<std::string> output_names;


  protected:
    unsigned max_var_;
    std::vector<unsigned> latches_;
    std::vector<unsigned> outputs_;
    std::vector<std::pair<unsigned, unsigned>> and_gates_;
    // Cache the function computed by each variable as a bdd.
    std::unordered_map<unsigned, bdd> var2bdd_;
    std::unordered_map<bdd, unsigned, bdd_hash> bdd2var_;

  public:
    aig(const std::set<std::string>& inputs,
        const std::set<std::string>& outputs,
        unsigned num_latches)
        : num_inputs(inputs.size()),
          num_outputs(outputs.size()),
          num_latches(num_latches),
          input_names(inputs),
          output_names(outputs),
          max_var_((inputs.size() + num_latches) * 2),
          latches_(num_latches),
          outputs_(outputs.size())
    {
      bdd2var_[bddtrue] = aig_true();
      var2bdd_[aig_true()] = bddtrue;
      bdd2var_[bddfalse] = aig_false();
      var2bdd_[aig_false()] = bddfalse;

      bdd2var_.reserve(4 * (num_inputs + num_latches));
      var2bdd_.reserve(4 * (num_inputs + num_latches));
    }

    aig(unsigned num_inputs, unsigned num_latches, unsigned num_outputs)
        : aig(name_vector(num_inputs, "in"), name_vector(num_outputs, "out"),
              num_latches)
    {
    }

    const std::vector<unsigned>& outputs() const
    {
      return outputs_;
    }


    const std::vector<unsigned>& latches() const
    {
      return latches_;
    };

    unsigned num_gates() const
    {
      return and_gates_.size();
    };
    const std::vector<std::pair<unsigned, unsigned>>& gates() const
    {
      return and_gates_;
    };

    unsigned max_var() const
    {
      return max_var_;
    };

    // register the bdd corresponding the an
    // aig literal
  protected:
    void register_new_lit_(unsigned v, const bdd &b);

  public:
    void register_latch(unsigned i, const bdd& b);

    void register_input(unsigned i, const bdd& b);

    unsigned input_var(unsigned i) const;

    unsigned latch_var(unsigned i) const;

    unsigned gate_var(unsigned i) const;

    void set_output(unsigned i, unsigned v);

    void set_latch(unsigned i, unsigned v);

    static constexpr unsigned aig_true() noexcept
    {
      return 1;
    };

    static constexpr unsigned aig_false() noexcept
    {
      return 0;
    };

    unsigned aig_not(unsigned v);

    unsigned aig_and(unsigned v1, unsigned v2);

    unsigned aig_and(std::vector<unsigned> vs);

    unsigned aig_or(unsigned v1, unsigned v2);

    unsigned aig_or(std::vector<unsigned> vs);

    unsigned aig_pos(unsigned v);

    void remove_unused();

    // Takes a bdd, computes the corresponding literal
    // using its DNF
    unsigned bdd2DNFvar(bdd b);

    // Takes a bdd, computes the corresponding literal
    // using its INF
    static aig_ptr parse_aag(const std::string& aig_txt);

    unsigned bdd2INFvar(bdd b);
  };

  SPOT_API std::ostream &
  print_aiger(std::ostream &os, const_aig_ptr circuit, const char *opt);

  SPOT_API aig_ptr
  strategy_to_aig(const const_twa_ptr &aut, const char *mode);

  SPOT_API aig_ptr
  strategies_to_aig(const std::vector<const_twa_ptr>& strat_vec, const char *mode);

  SPOT_API aig_ptr
  strategy_to_aig(const twa_ptr& aut, const char *mode,
                  const std::set<std::string>& ins,
                  const std::set<std::string>& outs);

  SPOT_API aig_ptr
  strategies_to_aig(const std::vector<twa_ptr>& strat_vec, const char *mode,
                    const std::set<std::string>& ins,
                    const std::vector<std::set<std::string>>& outs);
}
